Practical 1-(arrays)customer management

-------------------------------------------------------------------
#include <iostream>
#include <string>
using namespace std;

class Coustomer {
public:
    int id;
    long long phone;
    string name;
    double bill;

    void read() {
        cout << "Enter Coustomer ID: ";
        cin >> id;
        cout << "Enter Coustomer Name: ";
        cin.ignore();
        getline(cin, name);
        cout << "Enter Phone Number: ";
        cin >> phone;
        cout << "Enter Bill Amount ($): ";
        cin >> bill;
        cout << "\n";
    }

    void display() {
        cout << "\n--- Coustomer ---\n";
        cout << "Coustomer ID  : " << id << endl;
        cout << "Name          : " << name << endl;
        cout << "Phone Number  : " << phone << endl;
        cout << "Bill Amount   : $" << bill << endl;
    }

    void insert() {
        cout << "\nInserting New Record...\n";
        read();
    }
};


void delete_data(Coustomer s[], int &n) {
    int cID;
    cout << "Enter Coustomer ID to delete Record: ";
    cin >> cID;

    int index = -1;
    for (int i = 0; i < n; i++) {
        if (s[i].id == cID) {
            index = i;
            break;
        }
    }

    if (index == -1) {
        cout << "Coustomer ID not found!\n";
        return;
    }

    for (int i = index; i < n - 1; i++) {
        s[i] = s[i + 1];
    }
    n--;
    cout << "Record deleted successfully!\n";
}


void update_data(Coustomer s[], int n) {
    int cID, choice;
    cout << "Enter Coustomer ID to update Record: ";
    cin >> cID;

    for (int i = 0; i < n; i++) {
        if (s[i].id == cID) {
            cout << "\n1. Update Coustomer ID\n";
            cout << "2. Update Coustomer Name\n";
            cout << "3. Update Coustomer Phone\n";
            cout << "4. Update Final Bill Amount\n";
            cout << "Enter choice: ";
            cin >> choice;

            switch (choice) {
                case 1:
                    cout << "Enter new Coustomer ID: ";
                    cin >> s[i].id;
                    break;
                case 2:
                    cout << "Enter Coustomer Name: ";
                    cin.ignore();
                    getline(cin, s[i].name);
                    break;
                    case 3:
                    cout << "Enter new Phone Number: ";
                    cin >> s[i].phone;
                    break;
                case 4:
                    cout << "Enter Final Amount ($): ";
                    cin >> s[i].bill;
                    break;
                default:
                    cout << "Invalid choice!\n";
            }
            cout << "Record updated successfully!\n";
            return; 
        }
    }
    cout << "Coustomer ID not found!\n";
}

int main() {
    int n;
    
    Coustomer s[100];

    int c;

    do {
        cout << "\n**** MENU ****\n";
        cout << "1. Fill Details\n";
        cout << "2. Display\n";
        cout << "3. Insert\n";
        cout << "4. Delete Data\n";
        cout << "5. Update Data\n";
        cout << "6. Exit\n";
        cout << "Enter choice: ";
        cin >> c;

        switch (c) {
            case 1:
                cout << "Enter Total Enrollments: ";
                cin >> n;
                cout << "ENTER DETAILS FOR RECORDS\n";
                for (int i = 0; i < n; i++) {
                    s[i].read();
                }
                break;

            case 2:
                cout << "\nTOTAL RECORDS\n";
                for (int i = 0; i < n; i++) {
                    s[i].display();
                }
                break;

            case 3:
                if (n < 100) {
                    s[n].insert();
                    n++;
                } else {
                    cout << "Record limit reached!\n";
                }
                break;

            case 4:
                delete_data(s, n);
                break;

            case 5:
                update_data(s, n);
                break;

            case 6:
                cout << "Exiting...\n";
                break;

            default:
                cout << "Invalid choice!\n";
        }
    } while (c != 6);

    return 0;
}
-----------------------------------------------------------------
Prac 1-(array)aadhar card management
--------------------------------------------------------------------
#include <iostream>
using namespace std;

// Structure to store Aadhar details
struct Aadhar {
    long long number; 
    string name;
    int age;
};

int main() {
    Aadhar data[100];   // Array to store records
    int n = 0;          // Current number of records
    int choice, pos;

    while (true) {

        // Menu options
        cout << "\n--- Aadhar Card Management System ---\n";
        cout << "1. Read (Add Records)\n";
        cout << "2. Display Records\n";
        cout << "3. Insert at Position\n";
        cout << "4. Update Record\n";
        cout << "5. Delete Record\n";
        cout << "6. Exit\n";
        cout << "Enter choice: ";
        cin >> choice;

        // READ / ADD RECORDS
        if (choice == 1) {
            cout << "How many records do you want to add? ";
            cin >> n;

            for (int i = 0; i < n; i++) {
                cout << "\nRecord " << i + 1 << ":\n";
                cout << "Aadhar Number: ";
                cin >> data[i].number;
                cout << "Name: ";
                cin >> data[i].name;
                cout << "Age: ";
                cin >> data[i].age;
            }
        }

        // DISPLAY RECORDS
        else if (choice == 2) {
            if (n == 0) {
                cout << "No records available.\n";
            } else {
                cout << "\n--- Aadhar Records ---\n";
                for (int i = 0; i < n; i++) {
                    cout << i + 1 << ". "
                         << data[i].number << "  "
                         << data[i].name << "  "
                         << data[i].age << "\n";
                }
            }
        }

        // INSERT RECORD AT POSITION
        else if (choice == 3) {
            cout << "Enter position to insert (1 to " << n + 1 << "): ";
            cin >> pos;

            // Validate position
            if (pos < 1 || pos > n + 1) {
                cout << "Invalid position!\n";
            } else {
                // Shift elements to make space
                for (int i = n; i >= pos; i--) {
                    data[i] = data[i - 1];
                }

                // Insert new record
                cout << "Enter Aadhar Number: ";
                cin >> data[pos - 1].number;
                cout << "Name: ";
                cin >> data[pos - 1].name;
                cout << "Age: ";
                cin >> data[pos - 1].age;

                n++;
                cout << "Inserted Successfully.\n";
            }
        }

        // UPDATE RECORD
        else if (choice == 4) {
            cout << "Enter record number to update (1 to " << n << "): ";
            cin >> pos;

            if (pos < 1 || pos > n) {
                cout << "Invalid record number!\n";
            } else {
                // Take new values
                cout << "New Aadhar Number: ";
                cin >> data[pos - 1].number;
                cout << "New Name: ";
                cin >> data[pos - 1].name;
                cout << "New Age: ";
                cin >> data[pos - 1].age;

                cout << "Updated Successfully.\n";
            }
        }

        // DELETE RECORD
        else if (choice == 5) {
            cout << "Enter record number to delete (1 to " << n << "): ";
            cin >> pos;

            if (pos < 1 || pos > n) {
                cout << "Invalid record number!\n";
            } else {
                // Shift records left to fill the gap
                for (int i = pos - 1; i < n - 1; i++) {
                    data[i] = data[i + 1];
                }

                n--;
                cout << "Deleted Successfully.\n";
            }
        }

        // EXIT PROGRAM
        else if (choice == 6) {
            cout << "Exiting...\n";
            break;
        }

        // INVALID CHOICE
        else {
            cout << "Invalid choice! Try again.\n";
        }
    }

    return 0;
}
----------------------------------------------------------------------
prac 1- (array)lib management
-----------------------------------------------------------------
#include <iostream>
using namespace std;

// Structure to store book details
struct Book {
    int id;
    string title;
    string author;
};

int main() {
    Book lib[100];   // Array of books
    int n = 0;       // Number of books
    int choice, pos;

    while (true) {

        // Menu
        cout << "\n--- Library Management System ---\n";
        cout << "1. Add Books\n";
        cout << "2. Display Books\n";
        cout << "3. Insert Book at Position\n";
        cout << "4. Update Book\n";
        cout << "5. Delete Book\n";
        cout << "6. Exit\n";
        cout << "Enter your choice: ";
        cin >> choice;

        // ADD BOOKS
        if (choice == 1) {
            cout << "How many books do you want to add? ";
            cin >> n;

            for (int i = 0; i < n; i++) {
                cout << "\nBook " << i + 1 << ":\n";
                cout << "Book ID: ";
                cin >> lib[i].id;
                cout << "Title: ";
                cin >> lib[i].title;
                cout << "Author: ";
                cin >> lib[i].author;
            }
        }

        // DISPLAY BOOKS
        else if (choice == 2) {
            if (n == 0) {
                cout << "No books available.\n";
            } else {
                cout << "\n--- Library Books ---\n";
                for (int i = 0; i < n; i++) {
                    cout << i + 1 << ". ID: " << lib[i].id
                         << "  Title: " << lib[i].title
                         << "  Author: " << lib[i].author << "\n";
                }
            }
        }

        // INSERT BOOK
        else if (choice == 3) {
            cout << "Enter position to insert (1 to " << n + 1 << "): ";
            cin >> pos;

            if (pos < 1 || pos > n + 1) {
                cout << "Invalid position!\n";
            } else {
                // Shift elements right
                for (int i = n; i >= pos; i--) {
                    lib[i] = lib[i - 1];
                }

                // Insert new book
                cout << "Book ID: ";
                cin >> lib[pos - 1].id;
                cout << "Title: ";
                cin >> lib[pos - 1].title;
                cout << "Author: ";
                cin >> lib[pos - 1].author;

                n++;
                cout << "Book inserted successfully.\n";
            }
        }

        // UPDATE BOOK
        else if (choice == 4) {
            cout << "Enter book number to update (1 to " << n << "): ";
            cin >> pos;

            if (pos < 1 || pos > n) {
                cout << "Invalid book number!\n";
            } else {
                cout << "New Book ID: ";
                cin >> lib[pos - 1].id;
                cout << "New Title: ";
                cin >> lib[pos - 1].title;
                cout << "New Author: ";
                cin >> lib[pos - 1].author;

                cout << "Book updated successfully.\n";
            }
        }

        // DELETE BOOK
        else if (choice == 5) {
            cout << "Enter book number to delete (1 to " << n << "): ";
            cin >> pos;

            if (pos < 1 || pos > n) {
                cout << "Invalid book number!\n";
            } else {
                // Shift left
                for (int i = pos - 1; i < n - 1; i++) {
                    lib[i] = lib[i + 1];
                }

                n--;
                cout << "Book deleted successfully.\n";
            }
        }

        // EXIT
        else if (choice == 6) {
            cout << "Exiting...\n";
            break;
        }

        else {
            cout << "Invalid choice! Try again.\n";
        }
    }

    return 0;
}

-----------------------------------------------------------------------
Practical 2-2d array sparx matrix
--------------------------------------------------------------------
#include <iostream>
using namespace std;
#define MAX 100
class Sparse{
public:
	int A[MAX][MAX];
	int B[MAX][3];
	int transpose[MAX][3];
	int sum[MAX][3];
	int rows,cols;
	void read(){
		cout << "Enter Rows and Columns: ";
		cin >> rows >> cols;
		cout <<"Enter Elements in Matrix\n";
		for (int i=0; i < rows; i++){
			for (int j = 0; j<cols; j++){
				cin >> A[i][j];
			}
		}
	}
	void convert(){
		int k = 1;
		for (int i=0; i<rows; i++){
			for (int j=0; j < cols; j++){
				if (A[i][j] != 0){
					B[k][0] = i;
					B[k][1] = j;
					B[k][2] = A[i][j];
					k++;
				}
			}
		}
		B[0][0]= rows;
		B[0][1]= cols;
		B[0][2]= k-1;
	}
		
	void display(){
		int terms = B[0][2]; 
		cout << "\nRows\tColumns\tValue\n";
		for (int i =0; i <= terms; i++){
			for ( int j =0; j < 3; j++){
				cout << B[i][j] << "\t";
			}
			cout <<"\n";
		}
	}
	
	void Transpose(){
		int k =1;
		for (int i =0; i < B[0][1]; i++){
			for(int j =1; j <= B[0][2]; j++){
				if(B[j][1] == i){
					transpose[k][0] = B[j][1];
					transpose[k][1] = B[j][0];
					transpose[k][2] = B[j][2];
					k++;
				}
			}
		}
		transpose[0][0]= cols;
		transpose[0][1]= rows;
		transpose[0][2]= k-1;
	}
	
	void fastTranspose(){
		int col = B[0][1];
		int t = B[0][2];
		int total[col] = {0};
		int index[col + 1]= {0};
		index[0] = 1;
		
		for(int i =1; i<= t; i++){
			total[B[i][1]]++;
		}
		for(int i=1;i < B[0][1]; i++){
			index[i] = index[i-1] + total[i-1];
		}

		for(int i =1; i<= B[0][2]; i++){
			int pos = index[B[i][1]]++;
			transpose[pos][0] = B[i][1];
			transpose[pos][1] = B[i][0];
			transpose[pos][2] = B[i][2];
		}
		transpose[0][0] = B[0][1];
		transpose[0][1] = B[0][0];
		transpose[0][2] = B[0][2];
	}

	void display1(){
		int terms = transpose[0][2]; 
		cout << "\nRows\tColumns\tValue\n";
		for (int i =0; i <= terms; i++){
			for ( int j =0; j < 3; j++){
				cout << transpose[i][j] << "\t";
			}
			cout <<"\n";
		}
	}
    
    void add(Sparse &b){
	int i =1, j=1, k=1;
	int t1 = B[0][2];
	int t2 = b.B[0][2];
	
	sum[0][0] = B[0][0];
	sum[0][1] = B[0][1];
	
	while(i <= t1 && j <= t2){
		if(B[i][0] == b.B[j][0]){
			if(B[i][1] == b.B[j][1]){
				sum[k][0] = B[i][0];
				sum[k][1] = B[i][1];
				sum[k][2] = B[i][2] + b.B[j][2];
				i++;
				j++;
				k++;
			}
			else{
				if(B[i][1] < b.B[j][1]){
					sum[k][0] = B[i][0];
					sum[k][1] = B[i][1];
					sum[k][2] = B[i][2];
					i++;
					k++;
				}
				else{
					if(B[i][1] > b.B[j][1]){
						sum[k][0] = b.B[j][0];
						sum[k][1] = b.B[j][1];
						sum[k][2] = b.B[j][2];
						j++;
						k++;
					}
				}
			}
		}
		else{
			if(B[i][0] > b.B[j][0]){
				sum[k][0] = b.B[j][0];
				sum[k][1] = b.B[j][1];
				sum[k][2] = b.B[j][2];
				j++;
				k++;
			}
			else{
				if(B[i][0] < b.B[j][0]){
					sum[k][0] = B[i][0];
					sum[k][1] = B[i][1];
					sum[k][2] = B[i][2];
					i++;
					k++;
				}
			}
		}	
	}
	while(j <= t2){
		sum[k][0] = b.B[j][0];
		sum[k][1] = b.B[j][1];
		sum[k][2] = b.B[j][2];
		j++;
		k++;
	}
	while(i <= t1){
		sum[k][0] = B[i][0];
		sum[k][1] = B[i][1];
		sum[k][2] = B[i][2];
		i++;
		k++;
	}
	sum[0][2] = k-1;
	
	int terms = sum[0][2];
		cout << "\nAddition of A & B Matrix"; 
		cout << "\nRows\tColumns\tValue\n";
		for (int i =0; i <= terms; i++){
			for ( int j =0; j < 3; j++){
				cout << sum[i][j] << "\t";
			}
			cout <<"\n";
		}
    }

	void Product(Sparse &b){
		int p=1;
		sum[0][0] = B[0][0];
		sum[0][1] = b.B[0][1];
		sum[0][2] = 0;
		for(int i=1; i <= B[0][2];i++){
			for(int j =1; j<= b.transpose[0][2]; j++){
				if(B[i][1] == b.transpose[j][1]){
					int r = B[i][0];
					int c = b.transpose[j][0];
					int v = B[i][2] * b.transpose[j][2];
					
					bool flag = false;
					for(int k = 1; k < p;k++){
						if(r == sum[k][0] && c == sum[k][1]){
							sum[k][2] += v;
							flag = true;
							break;
						}
					}
					if(!flag){
						sum[p][0] = r;
						sum[p][1] = c;
						sum[p][2] = v;
						p++;
					}
				}
			}
		}
		sum[0][2] = p-1;
		
		int terms = sum[0][2]; 
		cout << "\nMultiplication of A & B Matrix";
		cout << "\nRows\tColumns\tValue\n";
		for (int i =0; i <= terms; i++){
			for ( int j =0; j < 3; j++){
				cout << sum[i][j] << "\t";
			}
			cout <<"\n";
		}
		
	}
};

 
int main(){
	Sparse a,b;
	int choice = 0;

	do{

		cout <<"\n1. Enter Matrix\n";
		cout <<"2. Display Matrix\n";
		cout <<"3. Convert to Sparse Matrix\n";
		cout <<"4. Transpose of Matrix\n";
		cout <<"5. Fast Transpose of Matrix\n";
		cout <<"6. Addition of Matrix\n";
		cout <<"7. Multiplication of Matrix\n";
		cout <<"8. Exit !\n";
		cout << "Enter Choice (1-8): ";
		cin >> choice;
		switch (choice)
		{
		case 1: a.read();
			break;
		case 2: a.display();
			break;
		case 3: a.convert();
				a.display();
			break;
		case 4: a.Transpose();
				a.display1();
			break;
		case 5: a.fastTranspose();
				a.display1();
			break;
		case 6: a.read(); 
				a.convert();
				b.read();
				b.convert();
				a.add(b);
			break;
		case 7: a.read();
				a.convert();
				b.read();
				b.convert();
				a.Product(b);
			break;
		case 8: cout << "Existing ......... ! ";
			break;
		
		default:
			break;
		}

	}while (choice != 8);
	
	


  return 0;

}
-------------------------------------------------------------------------
Practical 3-linked list placement info system
--------------------------------------------------------------------------
#include <bits/stdc++.h>
#include <string>
using namespace std;

class Node
{
public:
    int rollno;
    string name;
    string college;
    string company;
    double gpa;
    double ctc;

    Node *next;
};

class Placement
{
    Node *head;

public:
    Placement()
    {
        head = NULL;
    }

    void create()
    {
        Node *temp = NULL;

        int n;
        cout << "Enter Number of Students data to fill List: ";
        cin >> n;
        while (n--)
        {
            Node *t = new Node;

            cout << "Enter Roll Number: ";
            cin >> t->rollno;
            cin.ignore();
            cout << "Enter Name: ";
            getline(cin, t->name);
            cout << "Enter College Name: ";
            getline(cin, t->college);
            cout << "Enter CPGA: ";
            cin >> t->gpa;
            cin.ignore();
            cout << "Enter Company Name: ";
            getline(cin, t->company);
            cout << "Enter LPA: ";
            cin >> t->ctc;

            cout << "\n";
            t->next = NULL;

            if (head == NULL)
            {
                head = t;
                temp = head;
            }
            else
            {
                temp->next = t;
                temp = temp->next;
            }
        }
    }

    void display()
    {
        Node *temp = head;

        if (head == NULL)
            cout << "List is Empty !\n";

        cout << "\n--- Student List ---\n";

        while (temp)
        {
            cout << "Roll Number : " << temp->rollno << "\n";
            cout << "Name        : " << temp->name << "\n";
            cout << "College Name: " << temp->college << "\n";
            cout << "CGPA        : " << temp->gpa << "\n";
            cout << "Company Name: " << temp->company << "\n";
            cout << "CTC         : " << temp->ctc << " LPA\n\n";

            temp = temp->next;
        }
    }

    void search()
    {
        Node *temp = head;
        int roll;
        cout << "Enter Roll Number to Search in the List: ";
        cin >> roll;

        while (temp)
        {
            if (temp->rollno == roll)
            {
                cout << "Roll Number " << roll << " Found in the List\n";
                break;
            }
            temp = temp->next;
        }
        if (temp == NULL)
        {
            cout << "Roll Number" << roll << " not Found in the List\n";
        }
    }

    void update()
    {
        Node *temp = head;
        int roll;
        cout << "Enter Roll Number to Update in the List: ";
        cin >> roll;

        while (temp)
        {
            if (temp->rollno == roll)
            {
                cout << "\n1. Roll Number\n";
                cout << "2. Name\n";
                cout << "3. College Name\n";
                cout << "4. CGPA\n";
                cout << "5. Company Name\n";
                cout << "6. CTC\n";
                cout << "7. Exit\n";

                int choice;
                cout << "Enter your Choice: ";
                cin >> choice;

                switch (choice)
                {
                case 1:
                    cout << "Enter New Roll Number: ";
                    cin >> temp->rollno;
                    break;

                case 2:
                    cout << "Enter New Name: ";
                    cin >> temp->name;
                    break;
                case 3:
                    cout << "Enter College Name: ";
                    cin.ignore();
                    getline(cin, temp->college);
                    break;

                case 4:
                    cout << "Enter New CGPA: ";
                    cin >> temp->gpa;
                    break;
                case 5:
                    cout << "Enter Company Name: ";
                    cin.ignore();
                    getline(cin, temp->company);
                    break;
                case 6:
                    cout << "Enter CTC: ";
                    cin >> temp->ctc;
                    break;

                default:
                    break;
                }
                break;
            }
            temp = temp->next;
        }
        if (temp == NULL)
        {
            cout << "Roll Number" << roll << " not Found in the List\n";
        }
    }

    void insertValue()
    {
        Node *t = new Node;
        Node *temp = head;

        int roll;
        cout << "Enter Roll Number After the New Data to be Stored: ";
        cin >> roll;

        while (temp)
        {
            if (temp->rollno == roll)
            {
                cout << "Enter Roll Number: ";
                cin >> t->rollno;
                cin.ignore();
                cout << "Enter Name: ";
                getline(cin, t->name);
                cout << "Enter College Name: ";
                getline(cin, t->college);
                cout << "Enter CPGA: ";
                cin >> t->gpa;
                cin.ignore();
                cout << "Enter Company Name: ";
                getline(cin, t->company);
                cout << "Enter LPA: ";
                cin >> t->ctc;

                cout << "\n";
                t->next = NULL;

                if (temp->next == NULL)
                {
                    temp->next = t;
                }
                else
                {
                    t->next = temp->next;
                    temp->next = t;
                }

                break;
            }
            temp = temp->next;
        }
    }

    void insertPosition()
    {
        Node *temp = head;
        Node *t = new Node;

        int pos;
        cout << "Enter Position After the New Data to be Stored: ";
        cin >> pos;

        cout << "Enter Roll Number: ";
        cin >> t->rollno;
        cin.ignore();
        cout << "Enter Name: ";
        getline(cin, t->name);
        cout << "Enter College Name: ";
        getline(cin, t->college);
        cout << "Enter CPGA: ";
        cin >> t->gpa;
        cin.ignore();
        cout << "Enter Company Name: ";
        getline(cin, t->college);
        cout << "Enter LPA: ";
        cin >> t->ctc;

        cout << "\n";
        t->next = NULL;

        int cnt = 0;
        while (temp)
        {
            cnt++;
            temp = temp->next;
        }

        if (pos == 0)
        {
            t->next = head;
            head = t;
        }
        else if (pos == cnt)
        {
            while (temp->next != NULL)
            {
                temp = temp->next;
            }
            temp->next = t;
        }
        else if (pos < cnt)
        {
            temp = head;
            for (int i = 1; i <= pos - 1; i++)
            {
                temp = temp->next;
            }
            t->next = temp->next;
            temp->next = t;
        }
        else if (pos > cnt)
        {
            cout << "Invalid Position --- Use position from 1 to " << cnt << "\n";
        }
    }

    void deleteValue()
    {
        Node *temp = head;
        Node *prev = NULL;
        int roll;
        cout << "Enter Roll Number to be deleted: ";
        cin >> roll;

        if (head == NULL)
        {
            cout << "List is Empty !\n";
        }
        while (temp != NULL)
        {
            if (temp->rollno == roll)
            {
                prev->next = temp->next;
                delete temp;
                break;
            }
            prev = temp;
            temp = temp->next;
        }

        if (temp == NULL)
        {
            cout << "Enter valid Roll Number !\n";
        }
    }

    void deletePosition()
    {
        Node *temp = head;
        Node *prev = NULL;

        int pos;
        cout << "Enter Position to be deleted: ";
        cin >> pos;
        if (pos == 1)
        {
            temp = head;
            head = head->next;
            delete temp;
        }
        int cnt = 0;
        while (temp != NULL)
        {
            cnt++;
            if (cnt == pos)
            {
                prev->next = prev->next->next;
                delete temp;
                break;
            }
            prev = temp;
            temp = temp->next;
        }
        if (temp == NULL)
        {
            cout << "Enter valid Roll Number !\n";
        }
    }

    void sortLL()
    {
        for (Node *temp = head; temp != NULL; temp = temp->next)
        {
            Node *mini = temp;
            for (Node *curr = temp; curr != NULL; curr = curr->next)
            {
                if (mini->rollno > curr->rollno)
                {
                    mini = curr;
                }
            }
            swap(temp->rollno, mini->rollno);
            swap(temp->name, mini->name);
            swap(temp->gpa, mini->gpa);
            swap(temp->ctc, mini->ctc);
            swap(temp->college, mini->college);
            swap(temp->company, mini->company);
        }
    }
    void reverse()
    {
        Node *p, *q, *r;
        p = NULL;
        q = head;
        r = NULL;

        while (q != NULL)
        {
            r = q->next;
            q->next = p;
            p = q;
            q = r;
        }
        head = p;
    }
};

int main()
{

    Placement S;
    int choice = 0;

    while (choice != 11)
    {
        cout << "\n--- Menu ---\n";
        cout << "1. Create Student List\t\t\t\t";
        cout << "2. Display Student List\n";
        cout << "3. Update Student List\t\t\t\t";
        cout << "4. Search in Student List\n";
        cout << "5. Insert Student Data by Roll Number\t\t";
        cout << "6. Insert Student Data by Position\n";
        cout << "7. Delete Student Data by Roll Number\t\t";
        cout << "8. Delete Student Data by Position\n";
        cout << "9. Sort the List\t\t\t\t";
        cout << "10. Reverse the List\n";
        cout << "11. -------- Exit --------\n";

        cout << "\nEnter Your Choice (1-9): ";
        cin >> choice;
        switch (choice)
        {
        case 1:
            S.create();
            break;
        case 2:
            S.display();
            break;
        case 3:
            S.update();
            break;
        case 4:
            S.search();
            break;
        case 5:
            S.insertValue();
            break;
        case 6:
            S.insertPosition();
            break;
        case 7:
            S.deleteValue();
            break;
        case 8:
            S.deletePosition();
            break;
        case 9:
            S.sortLL();
            break;
        case 10:
            S.reverse();
            break;
        case 11:
            cout << "Thanks for using our Service ðŸ˜ðŸ˜Š !\n";
            break;

        default:
            break;
        }
    }

    return 0;
}
----------------------------------------------------------------------------
prac 3- singly linked list railway reservation system
-----------------------------------------------------------------------
#include <iostream>
using namespace std;

// Structure for each passenger node
struct Passenger {
    int ticketNo;
    string name;
    int age;
    Passenger* next;
};

// Head pointer for linked list
Passenger* head = NULL;


// Function to insert passenger at end
void insertPassenger() {
    Passenger* temp = new Passenger();

    cout << "Enter Ticket Number: ";
    cin >> temp->ticketNo;
    cout << "Enter Name: ";
    cin >> temp->name;
    cout << "Enter Age: ";
    cin >> temp->age;

    temp->next = NULL;

    // If list empty
    if (head == NULL) {
        head = temp;
    }
    else {
        Passenger* p = head;
        while (p->next != NULL) {
            p = p->next;
        }
        p->next = temp;
    }

    cout << "Passenger inserted successfully.\n";
}


// Function to display all passengers
void display() {
    if (head == NULL) {
        cout << "No passengers found.\n";
        return;
    }

    Passenger* p = head;
    cout << "\n--- Passenger List ---\n";
    while (p != NULL) {
        cout << "Ticket: " << p->ticketNo
             << "  Name: " << p->name
             << "  Age: " << p->age << "\n";
        p = p->next;
    }
}


// Function to search passenger by ticket number
void searchPassenger() {
    int t;
    cout << "Enter Ticket Number to search: ";
    cin >> t;

    Passenger* p = head;
    while (p != NULL) {
        if (p->ticketNo == t) {
            cout << "Passenger Found!\n";
            cout << "Ticket: " << p->ticketNo
                 << "  Name: " << p->name
                 << "  Age: " << p->age << "\n";
            return;
        }
        p = p->next;
    }

    cout << "Passenger not found.\n";
}


// Function to update passenger details
void updatePassenger() {
    int t;
    cout << "Enter Ticket Number to update: ";
    cin >> t;

    Passenger* p = head;
    while (p != NULL) {
        if (p->ticketNo == t) {
            cout << "Enter New Name: ";
            cin >> p->name;
            cout << "Enter New Age: ";
            cin >> p->age;

            cout << "Record Updated Successfully.\n";
            return;
        }
        p = p->next;
    }

    cout << "Passenger not found.\n";
}


// Function to delete passenger by ticket number
void deletePassenger() {
    int t;
    cout << "Enter Ticket Number to delete: ";
    cin >> t;

    if (head == NULL) {
        cout << "List is empty.\n";
        return;
    }

    // If head is to be deleted
    if (head->ticketNo == t) {
        Passenger* temp = head;
        head = head->next;
        delete temp;
        cout << "Passenger deleted.\n";
        return;
    }

    // Search in list
    Passenger* p = head;
    while (p->next != NULL) {
        if (p->next->ticketNo == t) {
            Passenger* temp = p->next;
            p->next = p->next->next;
            delete temp;
            cout << "Passenger deleted.\n";
            return;
        }
        p = p->next;
    }

    cout << "Passenger not found.\n";
}


// Function to sort by ticket number (simple bubble sort)
void sortList() {
    if (head == NULL || head->next == NULL) {
        cout << "Not enough passengers to sort.\n";
        return;
    }

    for (Passenger* i = head; i->next != NULL; i = i->next) {
        for (Passenger* j = i->next; j != NULL; j = j->next) {
            if (i->ticketNo > j->ticketNo) {
                // Swap values (not nodes)
                swap(i->ticketNo, j->ticketNo);
                swap(i->name, j->name);
                swap(i->age, j->age);
            }
        }
    }

    cout << "List sorted by Ticket Number.\n";
}


// Main menu
int main() {
    int choice;

    while (true) {
        cout << "\n--- Railway Reservation System (SLL) ---\n";
        cout << "1. Insert Passenger\n";
        cout << "2. Display All\n";
        cout << "3. Search Passenger\n";
        cout << "4. Update Passenger\n";
        cout << "5. Sort by Ticket Number\n";
        cout << "6. Delete Passenger\n";
        cout << "7. Exit\n";
        cout << "Enter choice: ";
        cin >> choice;

        switch (choice) {
            case 1: insertPassenger(); break;
            case 2: display(); break;
            case 3: searchPassenger(); break;
            case 4: updatePassenger(); break;
            case 5: sortList(); break;
            case 6: deletePassenger(); break;
            case 7: return 0;
            default: cout << "Invalid choice!\n";
        }
    }
}
-------------------------------------------------------------------
prac 3-singly linked list billing system at mall
------------------------------------------------------------------
#include <iostream>
using namespace std;

// Structure (Node) to store item details
struct Item {
    int id;          // unique item ID
    string name;     // item name
    float price;     // item price
    Item* next;      // pointer to next node
};

// Head pointer of the linked list
Item* head = NULL;


// ---------------- INSERT ITEM ----------------
void insertItem() {
    Item* temp = new Item();

    cout << "Enter Item ID: ";
    cin >> temp->id;
    cout << "Enter Item Name: ";
    cin >> temp->name;
    cout << "Enter Price: ";
    cin >> temp->price;

    temp->next = NULL;

    // If list empty
    if (head == NULL) {
        head = temp;
    }
    else {
        Item* p = head;
        while (p->next != NULL)
            p = p->next;
        p->next = temp;
    }

    cout << "Item added successfully.\n";
}


// ---------------- DISPLAY / LIST ITEMS ----------------
void displayItems() {
    if (head == NULL) {
        cout << "No items available.\n";
        return;
    }

    cout << "\n--- Item List ---\n";
    Item* p = head;
    while (p != NULL) {
        cout << "ID: " << p->id
             << "  Name: " << p->name
             << "  Price: " << p->price << "\n";
        p = p->next;
    }
}


// ---------------- SEARCH ITEM BY ID ----------------
void searchItem() {
    int x;
    cout << "Enter Item ID to search: ";
    cin >> x;

    Item* p = head;
    while (p != NULL) {
        if (p->id == x) {
            cout << "\nItem Found:\n";
            cout << "ID: " << p->id
                 << "  Name: " << p->name
                 << "  Price: " << p->price << "\n";
            return;
        }
        p = p->next;
    }

    cout << "Item not found.\n";
}


// ---------------- UPDATE ITEM ----------------
void updateItem() {
    int x;
    cout << "Enter Item ID to update: ";
    cin >> x;

    Item* p = head;
    while (p != NULL) {
        if (p->id == x) {
            cout << "Enter New Name: ";
            cin >> p->name;
            cout << "Enter New Price: ";
            cin >> p->price;

            cout << "Item updated successfully.\n";
            return;
        }
        p = p->next;
    }

    cout << "Item not found.\n";
}


// ---------------- DELETE ITEM ----------------
void deleteItem() {
    int x;
    cout << "Enter Item ID to delete: ";
    cin >> x;

    if (head == NULL) {
        cout << "List is empty.\n";
        return;
    }

    // If head is to be deleted
    if (head->id == x) {
        Item* temp = head;
        head = head->next;
        delete temp;
        cout << "Item deleted.\n";
        return;
    }

    // Search inside the list
    Item* p = head;
    while (p->next != NULL) {
        if (p->next->id == x) {
            Item* temp = p->next;
            p->next = p->next->next;
            delete temp;
            cout << "Item deleted.\n";
            return;
        }
        p = p->next;
    }

    cout << "Item not found.\n";
}


// ---------------- SORT ITEMS (By ID) ----------------
void sortItems() {
    if (head == NULL || head->next == NULL) {
        cout << "Not enough items to sort.\n";
        return;
    }

    for (Item* i = head; i->next != NULL; i = i->next) {
        for (Item* j = i->next; j != NULL; j = j->next) {
            if (i->id > j->id) {
                // swap data
                swap(i->id, j->id);
                swap(i->name, j->name);
                swap(i->price, j->price);
            }
        }
    }

    cout << "Items sorted by ID.\n";
}


// ---------------- MAIN MENU ----------------
int main() {
    int choice;

    while (true) {
        cout << "\n--- Billing System at Mall (Singly Linked List) ---\n";
        cout << "1. Insert Item\n";
        cout << "2. List Items\n";
        cout << "3. Search Item\n";
        cout << "4. Update Item\n";
        cout << "5. Sort Items\n";
        cout << "6. Delete Item\n";
        cout << "7. Exit\n";
        cout << "Enter your choice: ";
        cin >> choice;

        switch (choice) {
            case 1: insertItem(); break;
            case 2: displayItems(); break;
            case 3: searchItem(); break;
            case 4: updateItem(); break;
            case 5: sortItems(); break;
            case 6: deleteItem(); break;
            case 7: return 0;
            default: cout << "Invalid choice! Try again.\n";
        }
    }

    return 0;
}

-----------------------------------------------------------------------
Practical 4-doubly linked list 
----------------------------------------------------------------------
#include <iostream>
using namespace std;

// Node structure for Doubly Linked List
struct Node {
    int marks;
    Node* prev;
    Node* next;
};

// Function to insert at end of DLL
void insertEnd(Node*& head, int val) {
    Node* temp = new Node();
    temp->marks = val;
    temp->next = NULL;
    temp->prev = NULL;

    if (head == NULL) {
        head = temp;
        return;
    }

    Node* p = head;
    while (p->next != NULL)
        p = p->next;

    p->next = temp;
    temp->prev = p;
}

// Display DLL
void display(Node* head) {
    if (head == NULL) {
        cout << "List is Empty.\n";
        return;
    }

    Node* p = head;
    while (p != NULL) {
        cout << p->marks << " ";
        p = p->next;
    }
    cout << "\n";
}

// Bubble sort on DLL
void sortList(Node* head) {
    if (head == NULL)
        return;

    for (Node* i = head; i->next != NULL; i = i->next) {
        for (Node* j = i->next; j != NULL; j = j->next) {
            if (i->marks > j->marks) {
                // Swap the data only
                int temp = i->marks;
                i->marks = j->marks;
                j->marks = temp;
            }
        }
    }
}

// Merge two sorted lists into a new sorted DLL
Node* mergeLists(Node* h1, Node* h2) {
    Node* result = NULL;

    // Pointers
    Node* p1 = h1;
    Node* p2 = h2;

    while (p1 != NULL && p2 != NULL) {
        if (p1->marks <= p2->marks) {
            insertEnd(result, p1->marks);
            p1 = p1->next;
        } else {
            insertEnd(result, p2->marks);
            p2 = p2->next;
        }
    }

    // Remaining nodes of list 1
    while (p1 != NULL) {
        insertEnd(result, p1->marks);
        p1 = p1->next;
    }

    // Remaining nodes of list 2
    while (p2 != NULL) {
        insertEnd(result, p2->marks);
        p2 = p2->next;
    }

    return result;
}


// --------------------- MAIN PROGRAM ---------------------
int main() {
    Node* list1 = NULL;
    Node* list2 = NULL;

    int n1, n2, val;

    cout << "Enter number of students in List 1: ";
    cin >> n1;

    cout << "Enter marks for List 1:\n";
    for (int i = 0; i < n1; i++) {
        cin >> val;
        insertEnd(list1, val);
    }

    cout << "Enter number of students in List 2: ";
    cin >> n2;

    cout << "Enter marks for List 2:\n";
    for (int i = 0; i < n2; i++) {
        cin >> val;
        insertEnd(list2, val);
    }

    // Sorting both lists
    sortList(list1);
    sortList(list2);

    cout << "\nSorted List 1: ";
    display(list1);

    cout << "Sorted List 2: ";
    display(list2);

    // Merging
    Node* merged = mergeLists(list1, list2);

    cout << "\nMerged Sorted List: ";
    display(merged);

    return 0;
}

-------------------------------------------------------------------------
Practical 5-circular linked list pizza management
------------------------------------------------------------------------
#include <iostream>
#include <string>
using namespace std;

class Node {
public:
    int ID;
    int quantity;
    string type;
    string size;
    Node* next;

    Node(int id, int qty, string t, string s) {
        ID = id;
        quantity = qty;
        type = t;
        size = s;
        next = NULL;
    }
};

class CLL {
    Node* head;
    int maxOrders;
    int count;

public:
    CLL(int max) {
        head = NULL;
        maxOrders = max;
        count = 0;
    }

    Node* createNode() {
        int id, qty;
        string type, size;

        cout << "Enter Order ID: ";
        cin >> id;
        cout << "Enter Quantity: ";
        cin >> qty;
        cout << "Enter Type: ";
        cin >> type;
        cout << "Enter Size (Small/Medium/Large): ";
        cin >> size;

        return new Node(id, qty, type, size);
    }

    void placeOrder() {
        if (count == maxOrders) {
            cout << "Order is full! Cannot take more orders." << endl;
            return;
        }

        Node* temp = createNode();

        if (head == NULL) {
            head = temp;
            head->next = head;
        } else {
            Node* t;
            for (t = head; t->next != head; t = t->next);
            t->next = temp;
            temp->next = head;
        }

        count++;
        cout << "Order Placed Successfully" << endl;
    }

    void serveOrder() {
        if (head == NULL) {
            cout << "No orders to serve" << endl;
            return;
        }

        Node* temp = head;

        if (head->next == head) {
            head = NULL;
        } 
        else {
            Node* t = head;
            while (t->next != head)
                t = t->next;
            
            head = head->next;
            t->next = head;
        }

        cout << "Order ID " << temp->ID << " served." << endl;
        delete temp;
        count--;
    }

    void displayOrders() {
        if (head == NULL) {
            cout << "No orders in the list." << endl;
            return;
        }

        Node* t = head;
        cout << "\nCurrent Orders in list:" << endl;

        do {
            cout << "ID: " << t->ID
                 << ", Quantity: " << t->quantity
                 << ", Type: " << t->type
                 << ", Size: " << t->size << endl;
            t = t->next;
        } while (t != head);
    }
};

int main() {
    int maxOrders;
    cout << "Enter maximum number of orders Pizza Parlor can take: ";
    cin >> maxOrders;

    CLL pizzaParlor(maxOrders);
    int choice;

    do {
        cout << "\n1. Place Order\n2. Serve Order\n3. Display Orders\n4. Exit\nEnter choice: ";
        cin >> choice;

        switch (choice) {
            case 1:
                pizzaParlor.placeOrder();
                break;
            case 2:
                pizzaParlor.serveOrder();
                break;
            case 3:
                pizzaParlor.displayOrders();
                break;
            case 4:
                cout << "Exit" << endl;
                break;
            default:
                cout << "Invalid choice. Try again." << endl;
        }

    } while (choice != 4);

    return 0;
}
-------------------------------------------------------------------------
Practical 6 stack
-----------------------------------------------------------------------
#include <iostream>
#include <stack>
#include <string>
using namespace std;

// Check if operator
bool isOperator(char c) {
    return (c == '+' || c == '-' || c == '*' || c == '/');
}

// --------------------------------------
// PREFIX TO INFIX
// --------------------------------------
string prefixToInfix(string prefix) {
    stack<string> st;

    for (int i = prefix.length() - 1; i >= 0; i--) {
        char ch = prefix[i];

        if (isalnum(ch)) {
            st.push(string(1, ch));
        }
        else if (isOperator(ch)) {
            string a = st.top(); st.pop();
            string b = st.top(); st.pop();

            string temp = "(" + a + ch + b + ")";
            st.push(temp);
        }
    }
    return st.top();
}

// --------------------------------------
// INFIX TO POSTFIX
// --------------------------------------
int precedence(char c) {
    if (c == '*' || c == '/') return 2;
    if (c == '+' || c == '-') return 1;
    return 0;
}

string infixToPostfix(string infix) {
    stack<char> st;
    string postfix = "";

    for (int i = 0; i < infix.length(); i++) {
        char ch = infix[i];

        if (isalnum(ch)) {
            postfix += ch;
        }
        else if (ch == '(') {
            st.push(ch);
        }
        else if (ch == ')') {
            while (!st.empty() && st.top() != '(') {
                postfix += st.top();
                st.pop();
            }
            if (!st.empty()) st.pop();  // remove '('
        }
        else if (isOperator(ch)) {
            while (!st.empty() && precedence(st.top()) >= precedence(ch)) {
                postfix += st.top();
                st.pop();
            }
            st.push(ch);
        }
    }

    while (!st.empty()) {
        postfix += st.top();
        st.pop();
    }

    return postfix;
}

// --------------------------------------
// POSTFIX EVALUATION
// --------------------------------------
int evaluatePostfix(string postfix) {
    stack<int> st;

    for (int i = 0; i < postfix.length(); i++) {
        char ch = postfix[i];

        if (isdigit(ch)) {
            st.push(ch - '0');
        }
        else if (isOperator(ch)) {
            int b = st.top(); st.pop();
            int a = st.top(); st.pop();

            switch (ch) {
            case '+': st.push(a + b); break;
            case '-': st.push(a - b); break;
            case '*': st.push(a * b); break;
            case '/': st.push(a / b); break;
            }
        }
    }

    return st.top();
}

// --------------------------------------
// MAIN MENU
// --------------------------------------
int main() {
    int choice;
    string exp;

    while (1) {
        cout << "\n--- Expression Conversion Using Stack ---\n";
        cout << "1. Prefix to Infix\n";
        cout << "2. Infix to Postfix\n";
        cout << "3. Postfix Evaluation\n";
        cout << "4. Exit\n";
        cout << "Enter choice: ";
        cin >> choice;

        switch (choice) {
        case 1:
            cout << "Enter Prefix Expression: ";
            cin >> exp;
            cout << "Infix: " << prefixToInfix(exp) << endl;
            break;

        case 2:
            cout << "Enter Infix Expression: ";
            cin >> exp;
            cout << "Postfix: " << infixToPostfix(exp) << endl;
            break;

        case 3:
            cout << "Enter Postfix Expression: ";
            cin >> exp;
            cout << "Evaluation Result: " << evaluatePostfix(exp) << endl;
            break;

        case 4:
            return 0;

        default:
            cout << "Invalid choice!\n";
        }
    }
}





--------------------------------------------------------------------------
Practical 7-sudoku
--------------------------------------------------------------------------
#include <bits/stdc++.h>
using namespace std;

#define UNASSIGNED 0
#define N 9

bool FindUnassignedLocation(int grid[N][N], int &row, int &col);
bool isSafe(int grid[N][N], int row, int col, int num);

bool SolveSudoku(int grid[N][N]) {
    int row, col;

    if (!FindUnassignedLocation(grid, row, col))
        return true; // success!

    for (int num = 1; num <= 9; num++) {
        if (isSafe(grid, row, col, num)) {
            grid[row][col] = num;

            if (SolveSudoku(grid))
                return true;

            grid[row][col] = UNASSIGNED; // backtrack
        }
    }
    return false; // triggers backtracking
}

bool FindUnassignedLocation(int grid[N][N], int &row, int &col) {
    for (row = 0; row < N; row++)
        for (col = 0; col < N; col++)
            if (grid[row][col] == UNASSIGNED)
                return true;
    return false;
}

bool UsedInRow(int grid[N][N], int row, int num) {
    for (int col = 0; col < N; col++)
        if (grid[row][col] == num)
            return true;
    return false;
}

bool UsedInCol(int grid[N][N], int col, int num) {
    for (int row = 0; row < N; row++)
        if (grid[row][col] == num)
            return true;
    return false;
}

bool UsedInBox(int grid[N][N], int boxStartRow, int boxStartCol, int num) {
    for (int row = 0; row < 3; row++)
        for (int col = 0; col < 3; col++)
            if (grid[row + boxStartRow][col + boxStartCol] == num)
                return true;
    return false;
}

bool isSafe(int grid[N][N], int row, int col, int num) {
    return !UsedInRow(grid, row, num) &&
           !UsedInCol(grid, col, num) &&
           !UsedInBox(grid, row - row % 3, col - col % 3, num) &&
           grid[row][col] == UNASSIGNED;
}

void printGrid(int grid[N][N]) {
    for (int row = 0; row < N; row++) {
        for (int col = 0; col < N; col++)
            cout << grid[row][col] << " ";
        cout << endl;
    }
}

int main() {
    int grid[N][N] = {
        {3, 0, 6, 5, 0, 8, 4, 0, 0},
        {5, 2, 0, 0, 0, 0, 0, 0, 0},
        {0, 8, 7, 0, 0, 0, 0, 3, 1},
        {0, 0, 3, 0, 1, 0, 0, 8, 0},
        {9, 0, 0, 8, 6, 3, 0, 0, 5},
        {0, 5, 0, 0, 9, 0, 6, 0, 0},
        {1, 3, 0, 0, 0, 0, 2, 5, 0},
        {0, 0, 0, 0, 0, 0, 0, 7, 4},
        {0, 0, 5, 2, 0, 6, 3, 0, 0}
    };

    if (SolveSudoku(grid) == true)
        printGrid(grid);
    else
        cout << "No solution exists";

    return 0;
}


-------------------------------------------------------------------------
Practical 8-round robin
----------------------------------------------------------------------
#include <iostream>
using namespace std;

#define MAX 50

class cir_que {
public:
    int item[MAX];
    int front, rear;

    cir_que() {
        front = rear = -1;
    }

    bool isEmpty() {
        return (front == -1);
    }

    bool isFull() {
        return ((front == 0 && rear == MAX - 1) || (front == rear + 1));
    }

    void enque(int x) {
        if (isFull()) {
            cout << "Queue is full!" << endl;
            return;
        }
        if (front == -1)
            front = rear = 0;
        else
            rear = (rear + 1) % MAX;
        item[rear] = x;
    }

    int deque() {
        if (isEmpty()) {
            return -1;
        }
        int x = item[front];
        if (front == rear)
            front = rear = -1;
        else
            front = (front + 1) % MAX;
        return x;
    }
};

void RoundRobin(int process[], int n, int arrival[], int burst[], int quantum) {
    cir_que q;
    int remaining[n], waiting[n] = {0}, turnaround[n] = {0};
    int completion[n] = {0};
    bool inQueue[n] = {false};
    int currentTime = 0, completed = 0;

    for (int i = 0; i < n; i++)
        remaining[i] = burst[i];

    cout << "\nGantt Chart (Process Execution Order):\n";

    for (int i = 0; i < n; i++) {
        if (arrival[i] <= currentTime && !inQueue[i]) {
            q.enque(i);
            inQueue[i] = true;
        }
    }

    while (completed < n) {
        if (q.isEmpty()) {
            currentTime++;
            for (int i = 0; i < n; i++) {
                if (arrival[i] <= currentTime && !inQueue[i]) {
                    q.enque(i);
                    inQueue[i] = true;
                }
            }
            continue;
        }

        int i = q.deque();
        cout << "| P" << process[i] << " ";

        if (remaining[i] > quantum) {
            remaining[i] -= quantum;
            currentTime += quantum;
        } else {
            currentTime += remaining[i];
            remaining[i] = 0;
            completion[i] = currentTime;
            turnaround[i] = completion[i] - arrival[i];
            waiting[i] = turnaround[i] - burst[i];
            completed++;
        }

        for (int j = 0; j < n; j++) {
            if (arrival[j] <= currentTime && !inQueue[j] && remaining[j] > 0) {
                q.enque(j);
                inQueue[j] = true;
            }
        }

        if (remaining[i] > 0)
            q.enque(i);
    }

    cout << "|\n\n";

    double totalWT = 0, totalTAT = 0;
    cout << "Process\tAT\tBT\tCT\tTAT\tWT\n";
    for (int i = 0; i < n; i++) {
        totalWT += waiting[i];
        totalTAT += turnaround[i];
        cout << "P" << process[i] << "\t" << arrival[i] << "\t" << burst[i] << "\t"
             << completion[i] << "\t" << turnaround[i] << "\t" << waiting[i] << endl;
    }

    cout << "\nAverage Waiting Time: " << totalWT / n;
    cout << "\nAverage Turnaround Time: " << totalTAT / n << endl;
}

int main() {
    int n, quantum;

    cout << "Enter number of processes: ";
    cin >> n;

    int process[n], arrival[n], burst[n];

    for (int i = 0; i < n; i++) {
        process[i] = i + 1;
        cout << "\nEnter Arrival Time for P" << process[i] << ": ";
        cin >> arrival[i];
        cout << "Enter Burst Time for P" << process[i] << ": ";
        cin >> burst[i];
    }

    cout << "\nEnter Time Quantum: ";
    cin >> quantum;

    RoundRobin(process, n, arrival, burst, quantum);

    return 0;
}



------------------------------------------------------------------------

Practical 9-doubly ended queue

------------------------------------------------------------------------



#include <bits/stdc++.h>
using namespace std;
class Node{
public:
	int data;
	Node *next;
};

class MyDeque{
	Node *front;
	Node *rear;
	
public:
	MyDeque(){
		front = NULL;
		rear = NULL;
	}
	
	void display(){
		if(front == NULL && rear == NULL){
			cout << "Deque is Empty\n";
		}
		else{
			Node *ptr = front;
			while(ptr != NULL){
				cout << ptr->data << " -> ";
				ptr = ptr->next;
			}
		}
	}
	
	void insert_front(int n){
		Node *temp = new Node;
		temp->data = n;
		temp->next = NULL;
		if(front == NULL && rear == NULL){
			front = rear = temp;
		}
		else{
			temp->next = front;
			front = temp;
		}
	}
	
	void insert_rear(int n){
		Node *temp = new Node;
		temp->data = n;
		temp->next = NULL;
		if(front == NULL && rear == NULL)
		{
			front = rear = temp;
		}
		else
		{
			rear->next = temp;
			rear = temp;
		}
	}
	
	void delete_front(){
		if(front == NULL && rear == NULL)
		{
			cout <<"Deque is Empty | Deletion not possible\n";
		}
		else if(front == rear)
		{
			Node *ptr = front;
			front = rear = NULL;
			delete ptr;	
		}
		else{
			Node *ptr = front;
			front = front->next;
			delete ptr;
		}
	}
	
	void delete_rear(){
		if(front == NULL && rear == NULL){
			cout << "Deque is Empty | Deletion not possible\n";
		}
		else if(front == rear){
			Node *ptr = rear;
			front = rear = NULL;
			delete ptr;
		}
		else{
			Node *temp = front;
			while(temp->next != NULL){
				temp = temp->next;
			}
			Node *ptr = rear;
			temp->next = NULL;
			rear = temp;
			delete ptr;
		}
	}
};
int main(){
	
	MyDeque Deque;
	int n;
	
	do{
		cout << "\n===== Menu =====\n";
		cout << "1. Insert at Front\n";
		cout << "2. Insert at Rear\n";
		cout << "3. Delete at Front\n";
		cout << "4. Delete at Rear\n";
		cout << "5. Display\n";
		cout << "6. Exit\n";
		
		int choice = 0;
		cout << "Enter your choice: ";
		cin >> choice;
		
		switch(choice){
			case 1:
				cout << "Enter element: ";
				cin >> n;
				Deque.insert_front(n);
				break;
			case 2:
				cout << "Enter element: ";
				cin >> n;
				Deque.insert_rear(n);
				break;
			case 3:
				Deque.delete_front();
				break;
			case 4:
				Deque.delete_rear();
				break;
			case 5:
				Deque.display();
				break;
			case 6:
				cout << "Exiting....";
				return 0;
		}
	}while(true);
	
	return 0;
}




--------------------------------------------------------------------------
Practical 10-searching and sorting
--------------------------------------------------------------------------
#include <iostream>
#include <string>
using namespace std;

struct Student {
    int roll;
    string name;
    float sgpa;
    string dept;
};

Student s[50];   // max 50 students
int n;           // actual count

// --------------------------------------------------------------
// a) Bubble Sort by Roll Number
// --------------------------------------------------------------
void bubbleSort() {
    for (int i = 0; i < n - 1; i++) {
        for (int j = 0; j < n - i - 1; j++) {
            if (s[j].roll > s[j + 1].roll) {
                Student temp = s[j];
                s[j] = s[j + 1];
                s[j + 1] = temp;
            }
        }
    }
}

// --------------------------------------------------------------
// b) Insertion Sort by Name
// --------------------------------------------------------------
void insertionSort() {
    for (int i = 1; i < n; i++) {
        Student key = s[i];
        int j = i - 1;

        while (j >= 0 && s[j].name > key.name) {
            s[j + 1] = s[j];
            j--;
        }
        s[j + 1] = key;
    }
}

// --------------------------------------------------------------
// c) Quick Sort by SGPA (Descending)
// --------------------------------------------------------------
int partitionQ(int low, int high) {
    float pivot = s[high].sgpa;
    int i = low - 1;

    for (int j = low; j < high; j++) {
        if (s[j].sgpa > pivot) { // descending
            i++;
            Student temp = s[i];
            s[i] = s[j];
            s[j] = temp;
        }
    }

    Student temp = s[i + 1];
    s[i + 1] = s[high];
    s[high] = temp;

    return i + 1;
}

void quickSort(int low, int high) {
    if (low < high) {
        int p = partitionQ(low, high);
        quickSort(low, p - 1);
        quickSort(p + 1, high);
    }
}

// --------------------------------------------------------------
// d) Linear Search by SGPA
// --------------------------------------------------------------
void linearSearchSGPA(float key) {
    int found = 0;

    cout << "\nStudents with SGPA " << key << ":\n";

    for (int i = 0; i < n; i++) {
        if (s[i].sgpa == key) {
            found = 1;
            cout << s[i].roll << "  " << s[i].name << "  " 
                 << s[i].sgpa << "  " << s[i].dept << endl;
        }
    }

    if (!found) cout << "No student found.\n";
}

// --------------------------------------------------------------
// e) Binary Search by Name (Non-Recursive)
// --------------------------------------------------------------
void binarySearchName(string key) {
    // First sort by name
    insertionSort();

    int low = 0, high = n - 1;
    int found = 0;

    cout << "\nSearch results for name: " << key << "\n";

    while (low <= high) {
        int mid = (low + high) / 2;

        if (s[mid].name == key) {
            found = 1;

            // print all matching (left side)
            int i = mid;
            while (i >= 0 && s[i].name == key) {
                cout << s[i].roll << " " << s[i].name << " " 
                     << s[i].sgpa << " " << s[i].dept << endl;
                i--;
            }

            // print all matching (right side)
            i = mid + 1;
            while (i < n && s[i].name == key) {
                cout << s[i].roll << " " << s[i].name << " " 
                     << s[i].sgpa << " " << s[i].dept << endl;
                i++;
            }

            return;
        }
        else if (s[mid].name < key)
            low = mid + 1;
        else
            high = mid - 1;
    }

    if (!found) cout << "Name not found.\n";
}

// --------------------------------------------------------------
// f) Fibonacci Search (Search department = "Computer")
// --------------------------------------------------------------
int fibSearchDept(string deptName) {
    int fib2 = 0;
    int fib1 = 1;
    int fib = fib1 + fib2;

    while (fib < n) {
        fib2 = fib1;
        fib1 = fib;
        fib = fib1 + fib2;
    }

    int offset = -1;

    while (fib > 1) {
        int i = (offset + fib2 < n) ? offset + fib2 : n - 1;

        if (s[i].dept < deptName) {
            fib = fib1;
            fib1 = fib2;
            fib2 = fib - fib1;
            offset = i;
        }
        else if (s[i].dept > deptName) {
            fib = fib2;
            fib1 = fib1 - fib2;
            fib2 = fib - fib1;
        }
        else
            return i;
    }

    if (fib1 && offset + 1 < n && s[offset + 1].dept == deptName)
        return offset + 1;

    return -1;
}

// --------------------------------------------------------------
// Display Function
// --------------------------------------------------------------
void display() {
    cout << "\nRoll  Name  SGPA  Dept\n";
    for (int i = 0; i < n; i++) {
        cout << s[i].roll << "  "
             << s[i].name << "  "
             << s[i].sgpa << "  "
             << s[i].dept << endl;
    }
}

// --------------------------------------------------------------
// MAIN
// --------------------------------------------------------------
int main() {
    cout << "Enter number of students (min 15): ";
    cin >> n;

    for (int i = 0; i < n; i++) {
        cout << "\nEnter Roll, Name, SGPA, Dept: ";
        cin >> s[i].roll >> s[i].name >> s[i].sgpa >> s[i].dept;
    }

    int ch;
    while (1) {
        cout << "\n--- MENU ---\n";
        cout << "1. Sort by Roll (Bubble Sort)\n";
        cout << "2. Sort by Name (Insertion Sort)\n";
        cout << "3. Top 10 Toppers (Quick Sort)\n";
        cout << "4. Search by SGPA (Linear Search)\n";
        cout << "5. Search by Name (Binary Search)\n";
        cout << "6. Check if student belongs to Computer Dept (Fibonacci Search)\n";
        cout << "7. Display All\n";
        cout << "8. Exit\n";
        cout << "Enter choice: ";
        cin >> ch;

        if (ch == 1) {
            bubbleSort();
            cout << "Sorted by roll number:\n";
            display();
        }
        else if (ch == 2) {
            insertionSort();
            cout << "Sorted by name:\n";
            display();
        }
        else if (ch == 3) {
            quickSort(0, n - 1);
            cout << "Top 10 Toppers:\n";
            for (int i = 0; i < 10 && i < n; i++) {
                cout << s[i].roll << "  " << s[i].name << "  " 
                     << s[i].sgpa << "  " << s[i].dept << endl;
            }
        }
        else if (ch == 4) {
            float key;
            cout << "Enter SGPA to search: ";
            cin >> key;
            linearSearchSGPA(key);
        }
        else if (ch == 5) {
            string nm;
            cout << "Enter name: ";
            cin >> nm;
            binarySearchName(nm);
        }
        else if (ch == 6) {
            string deptName = "Computer";
            int idx = fibSearchDept(deptName);
            if (idx != -1)
                cout << "Student found in Computer Dept: " 
                     << s[idx].name << endl;
            else
                cout << "No student from Computer Dept found.\n";
        }
        else if (ch == 7) {
            display();
        }
        else if (ch == 8) {
            return 0;
        }
        else {
            cout << "Invalid choice.\n";
        }
    }
}


--------------------------------------------------------------------------

Practical 11-hashing cold drink shop

------------------------------------------------------------------------
#include <iostream>
using namespace std;

#define SIZE 6    // Hash table size

int hashTable[SIZE];  // stores keys
bool occupied[SIZE];  // marks if position is used (for Turbo C++ compatibility)

// Hash function
int hashFunction(int key) {
    return key % SIZE;
}

// Insert using linear probing
void insert(int key) {
    int index = hashFunction(key);

    // If slot empty ? place key
    if (!occupied[index]) {
        hashTable[index] = key;
        occupied[index] = true;
        cout << "Inserted at index " << index << endl;
        return;
    }

    // Collision ? apply linear probing
    cout << "Collision at index " << index 
         << ". Applying linear probing...\n";

    int i = (index + 1) % SIZE;

    // Search next empty position
    while (i != index) {
        if (!occupied[i]) {
            hashTable[i] = key;
            occupied[i] = true;
            cout << "Inserted at index " << i << endl;
            return;
        }
        i = (i + 1) % SIZE;
    }

    cout << "Hash table is FULL. Cannot insert key: " << key << endl;
}

// Display hash table
void display() {
    cout << "\n--- Hash Table ---\n";
    for (int i = 0; i < SIZE; i++) {
        if (occupied[i])
            cout << i << " ? " << hashTable[i] << endl;
        else
            cout << i << " ? EMPTY\n";
    }
}

int main() {
    // Initialize table as empty
    for (int i = 0; i < SIZE; i++)
        occupied[i] = false;

    int choice, key;

    while (true) {
        cout << "\n--- Cold Drink Shop Hash Table Menu ---\n";
        cout << "1. Insert Flavor Key\n";
        cout << "2. Display Hash Table\n";
        cout << "3. Exit\n";
        cout << "Enter your choice: ";
        cin >> choice;

        if (choice == 1) {
            cout << "Enter flavor key (integer): ";
            cin >> key;
            insert(key);
        }
        else if (choice == 2) {
            display();
        }
        else if (choice == 3) {
            return 0;
        }
        else {
            cout << "Invalid choice!\n";
        }
    }
}


------------------------------------------------------------------------
prac 11-hashing marks
--------------------------------------------------------------------------
#include <iostream>
using namespace std;

// Node for linked list (chaining)
struct Node {
    int data;
    Node* next;
};

// Hash table size = 20
#define SIZE 20

Node* hashTable[SIZE];   // array of pointers

// Hash function: key mod 20
int hashFunction(int key) {
    return key % SIZE;
}

// Insert key using separate chaining
void insert(int key) {
    int index = hashFunction(key);

    Node* newNode = new Node();
    newNode->data = key;
    newNode->next = NULL;

    // If bucket empty
    if (hashTable[index] == NULL) {
        hashTable[index] = newNode;
    }
    else {
        // Insert at end of linked list
        Node* temp = hashTable[index];
        while (temp->next != NULL)
            temp = temp->next;

        temp->next = newNode;
    }
}

// Display hash table
void display() {
    cout << "\n--- Hash Table (Separate Chaining) ---\n";

    for (int i = 0; i < SIZE; i++) {
        cout << i << " : ";

        Node* temp = hashTable[i];

        if (temp == NULL) {
            cout << "EMPTY";
        }
        else {
            while (temp != NULL) {
                cout << temp->data << " -> ";
                temp = temp->next;
            }
            cout << "NULL";
        }
        cout << endl;
    }
}

// MAIN
int main() {
    // Initialize table
    for (int i = 0; i < SIZE; i++) {
        hashTable[i] = NULL;
    }

    int marks[20] = {
        33,56,78,12,10,67,89,99,100,23,
        45,71,39,62,59,90,91,20,75,66
    };

    cout << "Inserting Marks into Hash Table...\n";

    for (int i = 0; i < 20; i++) {
        insert(marks[i]);
    }

    display();

    return 0;
}
-------------------------------------------------------------------------
prac 11-hashing mangoes
-------------------------------------------------------------------------
#include <iostream>
using namespace std;

#define SIZE 11

int hashTable[SIZE];
bool occupied[SIZE];

// Hash function
int hashFunction(int key) {
    return key % SIZE;
}

// Insert using Quadratic Probing (No Replacement)
void insert(int key) {
    int index = hashFunction(key);

    if (!occupied[index]) {
        hashTable[index] = key;
        occupied[index] = true;
        cout << "Inserted " << key << " at index " << index << endl;
        return;
    }

    cout << "Collision at index " << index << " for key " << key << endl;

    // Quadratic probing
    for (int i = 1; i < SIZE; i++) {
        int newIndex = (index + i * i) % SIZE;

        if (!occupied[newIndex]) {
            hashTable[newIndex] = key;
            occupied[newIndex] = true;
            cout << "Inserted " << key << " at index " << newIndex << endl;
            return;
        }
    }

    cout << "Hash table is FULL. Cannot insert " << key << endl;
}

// Display hash table
void display() {
    cout << "\n--- Hash Table (Quadratic Probing) ---\n";
    for (int i = 0; i < SIZE; i++) {
        if (occupied[i])
            cout << i << " -> " << hashTable[i] << endl;
        else
            cout << i << " -> EMPTY\n";
    }
}

int main() {
    // Initialize table slots as empty
    for (int i = 0; i < SIZE; i++)
        occupied[i] = false;

    int mangoes[11] = {25, 15, 10, 5, 11, 19, 16, 36, 42, 28, 32};

    cout << "Inserting mango varieties...\n";

    for (int i = 0; i < 11; i++) {
        insert(mangoes[i]);
    }

    display();

    return 0;
}


